\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Literature Review}
Language Servers have proven to be a powerful tool in creating cross-editor support for a wide variety of programming languages. As noted by Rask et al \cite[]{standardised_lsp_extensions}, the Language Server Protocol, which language servers use to communicate with code editors, ``changed the field of IDEs". This is because a language server can easily communicate with any IDE that supports the protocol, thus allowing IDEs to easily support a new language. Further, In surveying the effectiveness of language servers when building a language server for OCaml, Bour et al \cite[]{merlin_experience_report} note that ``adding support for a new editor to a language server requires no language-specific logic". This allows people who are not yet familiar with a given language to link a language server to their IDE of choice and begin programming. 
\\ \\
However, building a language server does not come without difficulties. Bour et al \cite[]{merlin_experience_report}, and the Visual Studio Code Language Server Extension documentation \cite[]{vsc_langserver_docs}, describe two main challenges that Language Servers face, that of ``incrementality and partiality":
\begin{itemize}
    \item Due to effiency constraints, the IDE only being able to send the portions of the document to the language server (incrementality)
    \item The language server having to parse incomplete portions of code that the user is writing (partiality)
\end{itemize}
In building their language server for OCaml, Bour et al solved these two issues by building their own parser, generated using an enhanced version of Menhir. This was needed because OCaml has a complex, recursive grammar, which made parsing incomplete portions of code a highly complex task. Logical English, however, has a very simple, non-recursive grammar, and our language server only concerns itself with parsing certain aspects of the language. Thus I expect it to be feasible for our language server to parse Logical English documents itself.
\\ \\
There is also existing literature on boilerplate generation from existing code. Wang et al \cite[]{classless_java} created a powerful compilation agent that auto-generates Java boilerplate code from more succint, annotated Java. The boilerplate code is generated at the Abstract Syntax Tree (AST) level: the code generator starts with the AST representing the annotated code and, using the Lombok compilation agent, produces an AST corresponding to non-annotated, boilerplate Java. Since neither templates nor heads of rules are recursive, I will likely find that a less complex representation can be favoured over AST.
\end{document}